/* autogenerated by Processing revision 1277 on 2021-11-13 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class transformedView extends PApplet {

TransformedView tv;
Player player;
Collisions collisions;
Seeker seeker;
Slider slider;

 public void setup() {
    /* size commented out by preprocessor */;
    player = new Player();
    tv = new TransformedView();
    tv.setWorldSize(-width * 0.5f, -height * 0.5f, width * 1.5f, height * 1.5f); // topLeft > bottomRight
    collisions = new Collisions();
    seeker = new Seeker();
    slider = new Slider();
}

 public void draw() {
    background(0);
    tv.resolveWorldBounds();
    // tv.follow(player.pos);
    // seeker.seek(player.pos);
    seeker.follow(player.pos);
    player.update();
    seeker.update();
    collisions.boundaries(player, tv.worldSize);
    player.show();
    seeker.show();
    slider.show();
    tv.drawBounds();
}
class Collisions {
     public void boundaries(Player player_, Vf4d worldSize_) {
        if (player_.pos.y + player_.h > worldSize_.y2) {
            player_.pos.y = worldSize_.y2 - player_.h;
            player_.vel.y = 0;
        } else if (player_.pos.y < worldSize_.y1) {
            player_.pos.y = worldSize_.y1;
            player_.vel.y = 0;
        }
        if (player_.pos.x + player_.w > worldSize_.x2) {
            player_.pos.x = worldSize_.x2 - player_.w;
            player_.vel.x = 0;
        } else if (player_.pos.x < worldSize_.x1) {
            player_.pos.x = worldSize_.x1;
            player_.vel.x = 0;
        }
    }
}
class Vi4d {
    int x1, y1, x2, y2;
}

class Vf4d {
    float x1, y1, x2, y2;
     public void set(float x1_, float y1_, float x2_, float y2_) {
        x1 = x1_;
        y1 = y1_;
        x2 = x2_;
        y2 = y2_;
    }
}
 public void keyPressed() {
    char keyLow = Character.toLowerCase(key);

    if (key == 'w') player.up(true);
    if (key == 's') player.down(true);
    if (key == 'a') player.left(true);
    if (key == 'd') player.right(true);
    // if (key == ' ' && !player.jump) player.jump(true);
    if (key == 'g') player.setGravity(true);
}

 public void keyReleased() {
    char keyLow = Character.toLowerCase(key);
    if (key == 'w') player.up(false);
    if (key == 's') player.down(false);
    if (key == 'a') player.left(false);
    if (key == 'd') player.right(false);
    // if (key == ' ') player.jump(false);
    if (key == 'g') player.setGravity(false);
}

 public void mousePressed() {
    if (mouseButton == CENTER) tv.startPan(mouseX, mouseY);
    if (mouseButton == LEFT && slider.selectorInside()) {
        slider.sliding = true;
    }
}
 public void mouseReleased() {
    if (mouseButton == LEFT && slider.sliding) slider.release();
}

 public void mouseDragged() {
    if (mouseButton == CENTER) tv.updatePan(mouseX, mouseY);
}

 public void mouseWheel(MouseEvent e) {
    if (e.getCount() > 0) tv.zoom(mouseX, mouseY, true); // zoom out
    else tv.zoom(mouseX, mouseY, false);
}
class Motion {
    PVector pos, vel, acc, maxVel;
    boolean limitVelX, limitVelY, minVelX, minVelY, resetAcc, frictionX;
    Motion() {
        pos = new PVector(0, 0);
        vel = new PVector(0, 0);
        acc = new PVector(0, 0);
        maxVel = new PVector (0, 0);
    }
     public void follow(PVector targetPos) {
        PVector force = PVector.sub(targetPos, pos);
        // println(force.mag());
        // force.setMag(10);
        float distance = force.mag();
        int range = 100;
        float maxSpeed = 20;
        if (distance < range) {
            maxSpeed = map(distance, 0, range, 0, 20);
            // println(maxSpeed);
        }
        force.setMag(maxSpeed);
        force.sub(vel);
        acc.add(force);
    }
     public void seek(PVector target) {
        PVector force = PVector.sub(target, pos);  // desired velocity
        force.setMag(5);
        force.sub(vel);
        force.limit(0.3f);
        acc.add(force);
    }
     public void update() {
        vel.add(acc);
        limit(vel);
        if (frictionX) vel.x *= .92f;
        pos.add(vel);
        if (resetAcc) acc.set(0, 0);
    }
     public void limit(PVector force) {
        if (limitVelX && force.x > maxVel.x) force.x = maxVel.x;
        else if (limitVelX && force.x < -maxVel.x) force.x = -maxVel.x;
        if (limitVelY && force.y > maxVel.y) force.y = maxVel.y;
        else if (limitVelY && force.y < -maxVel.y) force.y = -maxVel.y;
        if (minVelX && abs(force.x) < 0.2f) force.x = 0;
        if (minVelY && abs(force.y) < 0.2f) force.y = 0;
    }
}
class Player extends Motion {
    Vi4d screenPos;
    boolean up, down, left, right, jump;
    float jumpVel;
    int w, h;
    // String collisionSide;
    Player() {
        h = height / 12;
        w = h / 2;
        pos.set(width/2 - w/2, height/2 - h/2);
        limitVelX = true;
        limitVelY = true;
        minVelX = true;
        maxVel.set(25, 25);
        jumpVel = -15;
        screenPos = new Vi4d();
    }
     public void update() {
        // frictionX = collisionSide == "bottom" && !left && !right;
        super.update();
    }
     public void show() {
        fill(0, 128, 128);
        noStroke();
        tv.drawRect(pos.x, pos.y, pos.x + w, pos.y + h, screenPos);
    }

     public void setGravity(boolean flag) {
        if (flag) acc.y += 0.6f;
        else acc.y -= 0.6f;
    }
     public void up(boolean flag) {
        if (flag && !up) {
            up = true;
            acc.y -= .2f;
        } else if (!flag) {
            up = false;
            acc.y += .2f;
        }
    }
     public void down(boolean flag) {
        if (flag && !down) {
            down = true;
            acc.y += .2f;
        } else if (!flag) {
            down = false;
            acc.y -= .2f;
        }
    }
     public void left(boolean flag) {
        if (flag && !left) {
            left = true;
            acc.x -= .2f;
        } else if (!flag) {
            left = false;
            acc.x += .2f;
        }
    }
     public void right(boolean flag) {
        if (flag && !right) {
            right = true;
            acc.x += .2f;
        } else if (!flag) {
            right = false;
            acc.x -= .2f;
        }
    }
     public void jump(boolean flag) {
        // if (flag && collisionSide == "bottom") vel.y = jumpVel;
        jump = flag;
    }
    // PVector worldCenter() {
        // return new PVector(rect.x + w/2, rect.y + h/2);
    // }
     public PVector screenCenter() {
        return new PVector(pos.x + w/2, pos.y + h/2);
    }
}
class Seeker extends Motion {
    Vi4d screenPos;
    int w, h;
    Seeker() {
        h = height / 24;
        w = h / 2;
        pos.set(width * 0.3f, height * 0.3f);
        limitVelX = true;
        limitVelY = true;
        // minVelX = true;
        // minVelY = true;
        maxVel.set(20, 20);
        screenPos = new Vi4d();
        resetAcc = true;
    }
     public void update() {
        // frictionX = collisionSide == "bottom" && !left && !right;
        super.update();
    }
     public void show() {
        fill(128, 128, 0);
        noStroke();
        tv.drawRect(pos.x, pos.y, pos.x + w, pos.y + h, screenPos);
    }

    // void setGravity(boolean flag) {
    //     if (flag) acc.y += 0.6;
    //     else acc.y -= 0.6;
    // }
    // void up(boolean flag) {
    //     if (flag && !up) {
    //         up = true;
    //         acc.y -= .2;
    //     } else if (!flag) {
    //         up = false;
    //         acc.y += .2;
    //     }
    // }
    // void down(boolean flag) {
    //     if (flag && !down) {
    //         down = true;
    //         acc.y += .2;
    //     } else if (!flag) {
    //         down = false;
    //         acc.y -= .2;
    //     }
    // }
    // void left(boolean flag) {
    //     if (flag && !left) {
    //         left = true;
    //         acc.x -= .2;
    //     } else if (!flag) {
    //         left = false;
    //         acc.x += .2;
    //     }
    // }
    // void right(boolean flag) {
    //     if (flag && !right) {
    //         right = true;
    //         acc.x += .2;
    //     } else if (!flag) {
    //         right = false;
    //         acc.x -= .2;
    //     }
    // }
    // void jump(boolean flag) {
    //     // if (flag && collisionSide == "bottom") vel.y = jumpVel;
    //     jump = flag;
    // }
    // // PVector worldCenter() {
    //     // return new PVector(rect.x + w/2, rect.y + h/2);
    // // }
     public PVector screenCenter() {
        return new PVector(pos.x + w/2, pos.y + h/2);
    }
}
class Slider {
    PVector pos;
    int length = 900;
    float min, max, range, steps, current;
    float cPos;
    boolean sliding;
    Slider() {
        pos = new PVector(100, 100);
        min = 4;
        max = 12;
        range = max - min;
        steps = 0.5f;
        current = 8.5f;
    }
     public void show() {
        // selector
        fill(255, 0, 0);
        stroke(0, 0, 255);
        strokeWeight(1);
        // cPos = length * ((range / current) * steps);
        cPos = map(current, min, max, pos.x, pos.x + length);
        if (sliding) {
            float mP = map(mouseX, pos.x, pos.x + length, 0, range/steps);
            float sP = min + steps * (round(mP));
            cPos = map(sP, min, max, pos.x, pos.x + length);
            println(sP);
            // println(mP);
            ellipse(cPos, pos.y, 10, 10);
        } else ellipse(cPos, pos.y, 10, 10);
        // line
        stroke(255);
        strokeWeight(2);
        line(pos.x, pos.y, pos.x + length, pos.y);
        // steps
        strokeWeight(4);
        for (float i = 0; i <= range / steps; i++) {
            float xP = map(i, 0, range / steps, pos.x, pos.x + length);
            point(xP, pos.y - 15);
            textAlign(CENTER);
            text(String.format("%.2f" , min + i * steps), xP, pos.y - 30);
        }
    }
     public void release() {


        sliding = false;
    }
     public boolean selectorInside() {
        float distX = cPos - mouseX;
        float distY = pos.y - mouseY;
        float distance = sqrt((distX * distX) + (distY * distY));
        return distance < 10;
    }
}
class TransformedView extends Motion {
    PVector scale;
    Vi4d screenBounds, pan;
    Vf4d worldSize, worldZoom;
    float scaleValue;
    TransformedView() {
        rectMode(CORNERS);
        scale = new PVector(1, 1);
        screenBounds = new Vi4d();
        worldSize = new Vf4d();
        worldZoom = new Vf4d();
        pan = new Vi4d();
    }
     public void follow(PVector target) {
        // if (!seek) {
        //     posBefore.set(width/2, height/2);
        //     seek = true;
        // } else {
        //     posAfter.set(target_.x, target_.y);
        //     target.add(PVector.sub(posAfter, posBefore));
        //     posBefore.set(target_.x, target_.y);
        //     seek(target, flag);
        //     update();
            // resolveWorldBounds();
        // }
    }
     public void resolveWorldBounds() {
        // no resolve when gameworld < screen
        if (screenBounds.x2-screenBounds.x1 < width || screenBounds.y2 - screenBounds.y1 < height) return;
        if (pos.x < worldSize.x1) {
            vel.x = 0;
            pos.x = worldSize.x1;
        } else if (pos.x + width / scale.x > worldSize.x2) {
            vel.x = 0;
            pos.x = worldSize.x2 - width / scale.x;
        }
        if (pos.y < worldSize.y1) {
            pos.y = worldSize.y1;
            vel.y = 0;
        } else if (pos.y + height / scale.y > worldSize.y2) {
            vel.y = 0;
            pos.y = worldSize.y2 - height / scale.y;
        }
    }
     public void setWorldSize(float x1, float y1, float x2, float y2) {
        worldSize.set(x1, y1, x2, y2);
    }
     public void drawBounds() {
        stroke(255, 0, 0);
        strokeWeight(3 * scale.x); // strokeWidth not in collision detection yet, replace with rect ?aaaasasasasssssssss
        noFill();
        worldToScreenRect(worldSize.x1, worldSize.y1, worldSize.x2, worldSize.y2, screenBounds);
        rect(screenBounds.x1, screenBounds.y1, screenBounds.x2, screenBounds.y2);
    }
     public void drawRect(float worldX1, float worldY1, float worldX2, float worldY2, Vi4d screenPos) {
        worldToScreenRect(worldX1, worldY1, worldX2, worldY2, screenPos);
        rect(screenPos.x1, screenPos.y1, screenPos.x2, screenPos.y2);
    }

     public void worldToScreenRect(float worldX1, float worldY1, float worldX2, float worldY2, Vi4d screenPos) {
        screenPos.x1 = (int) ((worldX1 - pos.x) * scale.x);
        screenPos.y1 = (int) ((worldY1 - pos.y) * scale.y);
        screenPos.x2 = (int) ((worldX2 - pos.x) * scale.x);
        screenPos.y2 = (int) ((worldY2 - pos.y) * scale.y);
    }
     public void screenToWorldBeforeZoom(int screenX, int screenY) {
        worldZoom.x1 = screenX / scale.x + pos.x;
        worldZoom.y1 = screenY / scale.y + pos.y;
    }
     public void screenToWorldAfterZoom(int screenX, int screenY) {
        worldZoom.x2 = screenX / scale.x + pos.x;
        worldZoom.y2 = screenY / scale.y + pos.y;
    }
     public void startPan(int x, int y) {
        pan.x1 = x;
        pan.y1 = y;
    }
     public void updatePan(int x, int y) {
        // end pan
        pan.x2 = x;
        pan.y2 = y;
        // set pos
        pos.x -= (pan.x2 - pan.x1) / scale.x;
        pos.y -= (pan.y2 - pan.y1) / scale.y;
        // update pan
        pan.x1 = x;
        pan.y1 = y;
    }
     public void zoom(int x, int y, boolean flag) {
        screenToWorldBeforeZoom(x, y);
        scaleValue = flag ? 0.9f : 1.1f; // out : in
        scale.mult(scaleValue);
        screenToWorldAfterZoom(x, y);
        pos.x -= (worldZoom.x2 - worldZoom.x1);
        pos.y -= (worldZoom.y2 - worldZoom.y1);
    }
}


  public void settings() { size(1280, 720); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "transformedView" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
