/* autogenerated by Processing revision 1277 on 2021-11-09 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class platformer4 extends PApplet {

Player player;
Platforms platforms;
Button button;
Seeker seeker;
Camera camera;
String[] lines;
Slider slider;

 public void setup() {
    /* size commented out by preprocessor */;
    camera = new Camera(0, 0);
    camera = new Camera(-width * 0.5f, -height * 0.5f);
    player = new Player(-width * 0.2f, 100);
    platforms = new Platforms();
    button = new Button();
    slider = new Slider(width* 0.75f, height * 0.25f);
    seeker = new Seeker();
    camera.worldTopLeft = new PVector(-width * 0.5f, -height * 0.5f);
    camera.worldBottomRight = new PVector(width * 1.5f, height * 1.5f);
    camera.level();
}

 public void draw() {
    background(0);
    camera.follow(player.centerScreenPos(), true);
    seeker.seek(player.centerWorldPos(), true);
    seeker.update();
    platforms.update();
    player.update();
    collisions();
    platforms.show();
    player.show();
    seeker.show();
    button.show();
    camera.grid(128, 72);
    slider.show();
}
class Button {
    float x, y, w, h;
    boolean flag;
    Button() {
        x = width - 70;
        y = 30;
        w = 50;
        h = 20;
    }
     public void show() {
        fill(0);
        stroke(255);
        strokeWeight(2);
        rect(x, y, w, h);
        fill(255);
        textSize(16);
        textAlign(CENTER);
        text("gravity", x + w/2, y + h/2 + textDescent());
    }
     public void toggle() {
        flag = !flag;
    }
     public boolean inside() {
        return mouseX >= x && mouseX < x + w && mouseY >= y && mouseY < y + h;
    }
}
class Camera extends Motion {
    PVector worldTopLeft, worldBottomRight, scale, target, posBefore, posAfter;
    Boolean seek;
    Camera() {}
    Camera(float x, float y) {
        pos.set(x, y); // camera.pos.x, fOffsetY
        scale = new PVector(1, 1);
        target = new PVector(0, 0);
        posBefore = new PVector(0, 0);
        posAfter = new PVector(0, 0);
        maxForce = 0.6f;
        limitVelX = true;
        limitVelY = true;
        maxVel.set(5, 15);
        resetAcc = true;
        seek = false;
    }
     public void follow(PVector target_, boolean flag) {
        if (!seek) {
            posBefore.set(width/2, height/2);
            seek = true;
        } else {
            posAfter.set(target_.x, target_.y);
            target.add(PVector.sub(posAfter, posBefore));
            posBefore.set(target_.x, target_.y);
            seek(target, flag);
            update();
            // resolve gameworld bounds
            if (pos.x < -width * 0.5f) pos.x = -width * 0.5f;
            else if (pos.x > width * 0.5f) pos.x = width * 0.5f;
            if (pos.y > height/2) pos.y = height/2;
            else if (pos.y < -height/2) pos.y = -height/2;
        }
    }
    // Convert coordinates from World Space --> Screen Space
     public void worldToScreen(PVector worldPos, DVector screenPos) {
        // int ScreenX = (int) ((worldPos.x - pos.x) * scale.x);
        float screenX = (worldPos.x - pos.x) * scale.x;
        float screenY = (worldPos.y - pos.y) * scale.y;
        screenPos.setPos(screenX, screenY);
    }
    // Convert coordinates from Screen Space --> World Space
     public void screenToWorld(PVector screenPos, PVector worldPos) {
        float fWorldX = screenPos.x / scale.x + pos.x;
        float fWorldY = screenPos.y / scale.y + pos.y;
        worldPos.set(fWorldX, fWorldY);
    }
    String[] level;
     public void level() {
        level = new String[] {            
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xoooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooox",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxaaxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            "xoooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooox",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
        };
    }
     public void grid(int cols_, int rows_) {
        int cols = cols_;
        int rows = rows_;
        int colW = (width * 2) / cols;
        int rowH = (height * 2) / rows;
        char[] cells = new char[cols * rows];
        noFill();
        stroke(128);
        strokeWeight(1);
        for (int i = 0; i < cols; i++) {
            for (int j = 0; j < rows; j++) {
                switch (level[j].charAt(i)) {
                    case 'x' :
                        PVector worldPos = new PVector(i * colW - width * .5f, j * rowH - height * .5f);
                        DVector screenPos = new DVector(.0f, .0f);
                        worldToScreen(worldPos, screenPos);
                        noFill();
                        rect(screenPos.x, screenPos.y, colW, rowH);
                    break;
                    case 'o' :
                        PVector worldPos2 = new PVector(i * colW - width * .5f, j * rowH - height * .5f);
                        DVector screenPos2 = new DVector(.0f, .0f);
                        worldToScreen(worldPos2, screenPos2);
                        fill(100, 100, 100, 100);
                        rect(screenPos2.x, screenPos2.y, colW, rowH);
                    break;
                }
            }
        }
    }
//     float fSelectedCellX = 0;
//     float fSelectedCellY = 0;
// //     void run() {
// //         // mousePanBeforeZoom();
// //         // keyZoom();
// //         // mousePanAfterZoom();
// //         // grid();
// //         // selection();

// //     }
// //         float[] fWorldTopLeft = screenToWorld(0, 0);
    // float[] fWorldBottomRight = screenToWorld(width, height);
    // int nLinesDrawn = 0;

    // // Draw 10 horizontal lines
    // for (float y = 0; y <= 10; y++) {
    //     if (y >= fWorldTopLeft[1] && y <= fWorldBottomRight[1]) {
    //         float sx = 0, sy = y, ex = 10, ey = y;
    //         int[] start = worldToScreen(sx, sy);
    //         int[] end = worldToScreen(ex, ey);
    //         stroke(255);
    //         strokeWeight(1 / scale.x);
    //         line(start[0], start[1], end[0], end[1]);
    //         nLinesDrawn++;
    //     }
    // }

    // // Draw 10 vertical lines
    // for (float x = 0; x <= 10; x++) {
//         if (x >= fWorldTopLeft[0] && x <= fWorldBottomRight[0]) {
//             float sx = x, sy = 0, ex = x, ey = 10;
//             int[] start = worldToScreen(sx, sy);
//             int[] end = worldToScreen(ex, ey);
//             stroke(255);
//             strokeWeight(1 / scale.x);
//             line(start[0], start[1], end[0], end[1]);
//             nLinesDrawn++;
//         }
//     }

//     int[] selectedCell = worldToScreen(fSelectedCellX + 0.5, fSelectedCellY + 0.5);
//     fill(255, 0, 0);
//     noStroke();
//     circle(selectedCell[0], selectedCell[1], 0.3 * scale.x);

//     fill(255);
//     textSize(16);
//     text("Lines Drawn: " + nLinesDrawn, width/2, height * 0.1);
// }
// //     void keyZoom() {
// //         if (qPressed) {
// //             scale.x *= 1.03;
// //             scale.y *= 1.03;

// //         } else if (aPressed) {
// //             scale.x *= 0.97;
// //             scale.y *= 0.97;
// //         };
}
 public void collisions() {
    player.collisionSide = "none";
    for (Platform platform : platforms.platforms_) {
        platform.onTop = false;
        String collisionSide = rectCollision(player, platform);
        if (collisionSide == "bottom") {
            player.collisionSide = collisionSide;
            platform.onTop = true;
        } else if (player.collisionSide != "bottom") player.collisionSide = collisionSide;
    }
}

 public String rectCollision(Player r1, Platform r2) {
    // if (r1.vel.y < 0) return false;
    float dx = (r1.pos.x+r1.w/2) - (r2.pos.x+r2.w/2);
    float dy = (r1.pos.y+r1.h/2) - (r2.pos.y+r2.h/2);
    float combW = r1.w/2 + r2.w/2;
    float combH = r1.h/2 + r2.h/2;

    if (abs(dx) < combW && abs(dy) < combH) {
        float overlapX = combW - abs(dx);
        float overlapY = combH - abs(dy);
        if (overlapX >= overlapY) {
            if (dy > 0) {
                r1.vel.y = 0;
                r1.pos.y += overlapY;
                return "top";
            } else {
                r1.vel.y = 0;
                r1.pos.y -= overlapY;
                return "bottom";
            }
        } else {
            if (dx > 0) {
                r1.vel.x = 0;
                r1.pos.x += overlapX;
                return "left";
        } else {
            r1.vel.x = 0;
            r1.pos.x -= overlapX;
            return "right";
            }
        }
    }
    return "none";
}
class DVector {
    float x, y, w, h, r;
    DVector() {
        x = 0;
        y = 0;
        w = 0;
        h = 0;
    }
    DVector(PVector pos, float w_, float h_) {
        pos.x = x;
        pos.y = y;
        w = w_;
        h = h_;
    }
    DVector(float x_, float y_) {
        x = x_;
        y = y_;
    }
     public void setPos(float x_, float y_) {
        x = x_;
        y = y_;
    }
}
 public void keyPressed() {
    char keyLow = Character.toLowerCase(key);

    if (key == 'w') player.up(true);
    if (key == 's') player.down(true);
    if (key == 'a') player.left(true);
    if (key == 'd') player.right(true);
    if (key == ' ' && !player.jump) player.jump(true);
}

 public void keyReleased() {
    char keyLow = Character.toLowerCase(key);
    if (key == 'w') player.up(false);
    if (key == 's') player.down(false);
    if (key == 'a') player.left(false);
    if (key == 'd') player.right(false);
    if (key == ' ') player.jump(false);
}

 public void mouseReleased() {
    if (button.inside()) {
        button.toggle();
        player.setGravity(button.flag);
    }
}

float fStartPanX = 0;
float fStartPanY = 0;
float fScaleX = 1;
float fScaleY = 1;
 public void mousePressed() {
    if (mouseButton == LEFT) {
        // if (slider.inside()) {
        //     println("inside");
        // }
    }
    if (mouseButton == CENTER) {
        fStartPanX = mouseX;
        fStartPanY = mouseY;
    }
}

 public void mouseDragged() {
    if (mouseButton == CENTER) {
        camera.pos.x -= (mouseX - fStartPanX) / fScaleX;
        camera.pos.y -= (mouseY - fStartPanY) / fScaleY;
        fStartPanX = mouseX;
        fStartPanY = mouseY;
    }
}

float fMouseWorldX_BeforeZoom, fMouseWorldY_BeforeZoom;
float fMouseWorldX_AfterZoom, fMouseWorldY_AfterZoom;
 public void mousePanBeforeZoom() {
    PVector mouseWorld = new PVector();
    camera.screenToWorld(new PVector(mouseX, mouseY), mouseWorld);
    fMouseWorldX_BeforeZoom = mouseWorld.x;
    fMouseWorldY_BeforeZoom = mouseWorld.y;
}
 public void mousePanAfterZoom() {
    PVector mouseWorld = new PVector();
    camera.screenToWorld(new PVector(mouseX, mouseY), mouseWorld);
    fMouseWorldX_AfterZoom = mouseWorld.x;
    fMouseWorldY_AfterZoom = mouseWorld.y;
    camera.pos.x += (fMouseWorldX_BeforeZoom - fMouseWorldX_AfterZoom);
    camera.pos.y += (fMouseWorldY_BeforeZoom - fMouseWorldY_AfterZoom);
}
// void mouseReleased() {
//     // if (mouseButton == RIGHT) {
//     //     fSelectedCellX = (int) fMouseWorldX_AfterZoom;
//     //     fSelectedCellY = (int) fMouseWorldY_AfterZoom;
//     // }
 public void mouseWheel(MouseEvent e) {
    if (e.getCount() == 1) { // down - zoom out
        mousePanBeforeZoom();
        camera.scale.x *= 0.9f;
        camera.scale.y *= 0.9f;
        mousePanAfterZoom();
    } else if (e.getCount() == -1) { // up - zoom in
        mousePanBeforeZoom();
        camera.scale.x *= 1.1f;
        camera.scale.y *= 1.1f;
        mousePanAfterZoom();
    }
}
class Motion {
    PVector pos, vel, acc, maxVel;
    DVector rect, ellipse;
    float maxForce, w, h, r;
    boolean limitVelX, limitVelY, minVelX, minVelY, resetAcc, frictionX;
    Motion() {
        pos = new PVector(0, 0);
        vel = new PVector(0, 0);
        acc = new PVector(0, 0);
        maxVel = new PVector(0, 0);
        maxForce = 0;
    }
     public void update() {
        vel.add(acc);
        limit();
        if (frictionX) vel.x *= .92f;
        pos.add(vel);
        if (resetAcc) acc.set(0, 0);
    }
     public void seek(PVector target_, boolean arrive_) {
        PVector force = PVector.sub(target_, pos); // desired velocity
        int slowRadius = 100;
        float distance = force.mag();
        float maxSpeed;
        if (arrive_ && distance < slowRadius) maxSpeed = map(distance, 0, slowRadius, 0, maxVel.mag());
        else maxSpeed =  maxVel.mag();
        force.setMag(maxSpeed).sub(vel).limit(maxForce);
        acc.add(force);
    }
     public void limit() {
        if (limitVelX && vel.x > maxVel.x) vel.x = maxVel.x;
        else if (limitVelX && vel.x < -maxVel.x) vel.x = -maxVel.x;
        if (limitVelY && vel.y > maxVel.y) vel.y = maxVel.y;
        else if (limitVelY && vel.y < -maxVel.y) vel.y = -maxVel.y;
        if (minVelX && abs(vel.x) < 0.2f) vel.x = 0;
        if (minVelY && abs(vel.y) < 0.2f) vel.y = 0;
    }
     public void rectToScreenPos() {
        camera.worldToScreen(pos, rect);
    }
     public void ellipseToScreenPos() {
        camera.worldToScreen(pos, ellipse);
    }
}
class Platform extends Motion {
    float a;
    int col;
    boolean onTop, moveLeftRight, moveRightLeft;
    Platform(float x, float y, float w_, float h_) {
        col = color(0, 0, 255);
        pos.set(x, y);
        w = w_;
        h = h_;
        rect = new DVector();
        rect.w = w;
        rect.h = h;
        camera.worldToScreen(pos, rect);
        a = 0;
    }
     public void show() {
        fill(col);
        noStroke();
        rectToScreenPos();
        rect(rect.x, rect.y, rect.w, rect.h);
    }
     public void update() {
        float velo = 0;
        if (moveLeftRight) {
            velo = cos(a + PI) * 4;
            pos.x += velo;
            super.update();
            a += 0.03f;
        } else if (moveRightLeft) {
            velo = cos(a) * 4;
            pos.x += velo;
            super.update();
            a += 0.03f;
        }
        if (onTop) player.pos.x += velo;

    }
}

class Platforms {
    Platform[] platforms_;
    Platforms() {
        platforms_ = new Platform[7];
        platforms_[0] = new Platform(-width * 0.5f + 10, -height * 0.5f, width * 2 - 20, 10);
        platforms_[1] = new Platform(-width * 0.5f + 10, height * 1.5f - 10, width * 2 - 20, 10);
        platforms_[2] = new Platform(-width * 0.5f, -height * 0.5f, 10, height * 2);
        platforms_[3] = new Platform(width * 1.5f - 10, -height * 0.5f, 10, height * 2);
        platforms_[4] = new Platform(width * 0.25f - 100, height - 150, 200, 20);
        platforms_[4].col = color(100, 50, 25);
        platforms_[4].moveRightLeft = true;
        platforms_[5] = new Platform(width * 0.75f - 100, height - 150, 200, 20);
        platforms_[5].moveLeftRight = true;
        platforms_[5].col = color(100, 50, 25);
        platforms_[6] = new Platform(width * 0.5f - 100, height - 75, 200, 20);
        platforms_[6].col = color(100, 50, 25);
    }
     public void update() {
        for (Platform platform : platforms_) platform.update();
    }
     public void show() {
        for (Platform platform : platforms_) platform.show();
    }
}
class Player extends Motion {
    boolean up, down, left, right, jump;
    float jumpVel;
    String collisionSide;
    Player(float x, float y) {
        pos.set(x, y);
        w = 30;
        h = 60;
        limitVelX = true;
        limitVelY = true;
        minVelX = true;
        maxVel.set(5, 15);
        jumpVel = -15;
        rect = new DVector();
        rect.w = w;
        rect.h = h;
        camera.worldToScreen(pos, rect);
    }
     public void update() {
        frictionX = collisionSide == "bottom" && !left && !right;
        super.update();
    }
     public void show() {
        fill(200, 0, 0);
        noStroke();
        rectToScreenPos();
        rect(rect.x, rect.y, rect.w, rect.h);
    }
     public void setGravity(boolean flag) {
        if (flag) acc.y += 0.6f;
        else acc.y -= 0.6f;
    }
     public void up(boolean flag) {
        if (flag && !up) {
            up = true;
            acc.y -= .2f;
        } else if (!flag) {
            up = false;
            acc.y += .2f;
        }
    }
     public void down(boolean flag) {
        if (flag && !down) {
            down = true;
            acc.y += .2f;
        } else if (!flag) {
            down = false;
            acc.y -= .2f;
        }
    }
     public void left(boolean flag) {
        if (flag && !left) {
            left = true;
            acc.x -= .2f;
        } else if (!flag) {
            left = false;
            acc.x += .2f;
        }
    }
     public void right(boolean flag) {
        if (flag && !right) {
            right = true;
            acc.x += .2f;
        } else if (!flag) {
            right = false;
            acc.x -= .2f;
        }
    }
     public void jump(boolean flag) {
        if (flag && collisionSide == "bottom") vel.y = jumpVel;
        jump = flag;
    }
     public PVector centerWorldPos() {
        return new PVector(rect.x + w/2, rect.y + h/2);
    }
     public PVector centerScreenPos() {
        return new PVector(pos.x + w/2, pos.y + h/2);
    }
}
class Seeker extends Motion {
    PVector target, posBefore, posAfter;
    boolean seek;
    Seeker() {
        pos.set(20, 20);
        target = new PVector(0, 0);
        posBefore = new PVector(0, 0);
        posAfter = new PVector(0, 0);
        r = 5;
        maxForce = 0.6f;
        limitVelX = true;
        limitVelY = true;
        maxVel.set(5, 5);
        resetAcc = true;
        ellipse = new DVector();
        ellipse.r = r;
        seek = false;
    }
     public void show() {
        fill(0, 255, 0);
        noStroke();
        ellipseToScreenPos();
        ellipse(pos.x, pos.y, r*2, r*2);
    }
     public void follow(PVector target_, boolean flag) {
        
        if (!seek) {
            // posBefore.set(target_.x + target_.x, target_.y + target_.y);
            posBefore.set(-width * 0.2f, 100);
            seek = true;
        } else {
            posAfter.set(target_.x, target_.y);
            target.add(PVector.sub(posAfter, posBefore));
            posBefore.set(target_.x, target_.y);
            seek(target, flag);
            update();
            // resolve gameworld bounds
            if (pos.x < -width * 0.5f) pos.x = -width * 0.5f;
            else if (pos.x > width * 0.5f) pos.x = width * 0.5f;
            if (pos.y > height/2) pos.y = height/2;
            else if (pos.y < -height/2) pos.y = -height/2;
        }
    }
}
class Slider extends Motion {
    float min, max, current, step, length;
    int r;
    Slider(float x, float y) {
        pos.set(x, y);
        length = 100;
        min = 0;
        max = 0;
        current = 0;
        r = 5;
    }
     public void show() {
        stroke(255);
        strokeWeight(3 * camera.scale.x);
        line(pos.x, pos.y, pos.x + length, pos.y);
        noStroke();
        fill(255, 100, 50);
        println(length/current);
        ellipse(pos.x + current * length, pos.y, r*2, r*2);
    }
     public boolean inside() {
        // ellipse

        // line
        return true;
    }
}
// void showStats() {
//     fill(255);
//     textSize(16);
//     String ax = String.format("%.2f", player.acc.x);
//     String ay = String.format("%.2f", player.acc.y);
//     String vx = String.format("%.2f", player.vel.x);
//     String vy = String.format("%.2f", player.vel.y);
//     String px = String.format("%.2f", player.pos1.x);
//     String py = String.format("%.2f", player.pos1.y);
//     String s = "ax: " + ax + "  ay: " + ay +"  vx: " + vx + "  vy: " + vy + "  px: " + px + "  py: " + py;
//     s += "\nleft: " + player.left + "  right: " + player.right + "  jump: " + player.jump;
//     s += "\ncollisionSide: " + player.collisionSide;
//     text(s, 50, 50);
// }


  public void settings() { size(1280, 720); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "platformer4" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
